import pygrap
import os
from core.color import Color
from core.match import Matches

class Pattern:
    """Class that handle pattern matching

    Attributes:
     - cfg(Dict): Config of a patterns (see. config.py)
     - name(str): Name of the pattern (eg. "push_reg", "detour_call", ...)
     - ppath(str): Path to the Grap pattern.
     - fpath(str): Path to the binary file to analyze.
     - tpath(str): Path to the test file which is the DOT version of fpath
     - test_graph(pygrap.graph_t): Grap representation of the binary
     - matches(Matches): All matches of the pattern ppath in the file fpath
    """

    def __init__(self, cfg, fpath):
        """Initialization

        Arguments:
         - cfg(Dict): Config of a patterns (see. config.py)
         - fpath(str): Path to the binary file to analyze.
        """

        self.cfg = cfg
        self.name = cfg["name"]
        self.ppath = cfg["func_pattern"]
        self.fpath = fpath
        self.tpath = fpath + ".grapcfg"

        self._generate_graph()
        
        self._search()

    
    def _generate_graph(self):
        """Generate the DOT graph of the binary"""
        
        # generate the DOT graph of the binary
        # use_existing specifies wether an existing dot file should be used unchanged or overwritten
        pygrap.disassemble_file(bin_path=self.fpath,
                                dot_path=self.tpath,
                                use_existing=True)

        if not os.path.isfile(self.fpath):
            raise IOError("ERROR: the binary {} do not exist".format(self.fpath))

        if not os.path.isfile(self.tpath):
            raise IOError("ERROR: the graph file {} do not exist".format(self.tpath))

        # get grap test_graph
        self.test_graph = pygrap.getGraphFromPath(self.tpath)

    def _search(self):
        """Searching for the pattern in the binary"""

        print Color.step("Searching for the pattern {}".format(self.name))
        self.matches = Matches(self.cfg, self.test_graph)



