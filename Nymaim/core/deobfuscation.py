from core.patterns import Pattern
from core.patch import Patch
from core.color import Color
from miasm2.os_dep.linux_stdlib import linobjs

import struct
import core.config as cfg



class Deobfuscation:
    """"Deobfuscation skeleton class
    
    Attributes:
     - sb(Sandbox_Win_x86_32): Sandbox used for deobfuscation
     - pattern(Pattern): Pattern used to match the targeted deobfuscation function
     - mdis(): Miasm machine disassemble engine
    """

    def __init__(self, sb):
        """Initialization method

        Arguments:
         - sb(Sandbox_Win_x86_32): Sandbox used for deobfuscation
        """
        self.sb = sb
        self.mdis = self.sb.machine.dis_engine(self.sb.jitter.bs)
        self.pattern = None
    
class PushReg(Deobfuscation):
    """Deobfuscation function for the push_reg function.
    
    PushRed class inherits of Deobfuscation.

    Attributes:
     - cfg(Dict): Config of the PushReg patterns (see. config.py)
     - pattern(Pattern): Pattern with all matches
     - push_sbox(Dict): Substition box for the emulation
     - tmp_reg(str): Temporary string (need to be fixed)
    """
    push_sbox = {
            "EAX": 0xE1,
            "ECX": 0xE2,
            "EDX": 0xE3,
            "EBX": 0xE4,
            "EBP": 0xE5,
            "ESI": 0xE6,
            "EDI": 0xE7
    }
    tmp_str=""

    def __init__(self, sb):
        """Initialization"""
        Deobfuscation.__init__(self, sb)
        self.cfg = cfg.PATTERNS["push_reg"]
        self.pattern = Pattern(self.cfg, fpath=self.sb.fname)

        # deobfuscation
        self.deobfuscation()

        # patch
        self.patch()
    
    def deobfuscation(self):
        """ Deobfuscation of the push_reg function """
        
        print Color.step("Emulating each call to {}".format(self.pattern.name))

        # for each call to the function 
        for match_func in self.pattern.matches.matches:
            for args in match_func.args:
                push_arg = int(args["push"][0].info.arg1, 16)

                # init registers and call the targeted function
                self.init()
                self.sb.call_callback(match_func.func_addr, push_arg, cb=self.end)
                # save the deobfuscated instruction
                if self.tmp_str:
                    match_func.deobf_inst.append({ "args":args, "inst":self.tmp_str })
                    self.tmp_str = ""

    def patch(self):
        patch = Patch(self.sb)

        print Color.step("Patching each call to {} (can take a while)".format(self.pattern.name))
        for match_func in self.pattern.matches.matches:
            for elem in match_func.deobf_inst:
                args = elem["args"]
                inst = elem["inst"]

                start = args["push"][0].info.address
                end = args["call"][0].info.address + len(args["call"][0].info.opcode) + 1

                # patch the range with NOPs
                patch.nop_range(start, end)
                # write the deobfuscated instruction
                patch.patch(start, end, inst)


    def end(self, jitter):
        """ Callback"""
        value = struct.unpack("I", jitter.vm.get_mem(jitter.cpu.ESP, 4))[0]
        for (reg,val) in self.push_sbox.items():
            if val == value:
                self.tmp_str = "PUSH " + reg

        jitter.run = False
        return False

    def init(self):
        """ Initialize registers to identify which register was pushed"""
        jitter = self.sb.jitter

        jitter.cpu.EAX = self.push_sbox["EAX"]
        jitter.cpu.ECX = self.push_sbox["ECX"]
        jitter.cpu.EDX = self.push_sbox["EDX"]
        jitter.cpu.EBX = self.push_sbox["EBX"]
        jitter.cpu.EBP = self.push_sbox["EBP"]
        jitter.cpu.ESI = self.push_sbox["ESI"]
        jitter.cpu.EDI = self.push_sbox["EDI"]

class DetourCall(Deobfuscation):
    """Deobfuscation function for the detour_call function.
    
    Detour class inherits of Deobfuscation.

    Attributes:
     - cfg(Dict): Config of the PushReg patterns (see. config.py)
     - pattern(Pattern): Pattern with all matches
     - tmp(int): Temporary address value (need to be fixed)
    """

    tmp_str = 0

    def __init__(self, sb):
        """Initialization"""
        Deobfuscation.__init__(self, sb)
        self.cfg = cfg.PATTERNS["detour_call"]
        self.pattern = Pattern(self.cfg, fpath=self.sb.fname)

        # deobfuscation
        self.deobfuscation()

        # patch
        self.patch()
    
    def deobfuscation(self):
        """ Deobfuscation of the push_reg function """
        
        print Color.step("Emulating each call to {}".format(self.pattern.name))

        # for each call to the function 
        for match_func in self.pattern.matches.matches:
            for args in match_func.args:
                push_arg1 = int(args["push1"][0].info.arg1, 16)
                push_arg2 = int(args["push2"][0].info.arg1, 16)
                push_addr3 = args["push3"][0].info.address
                func_end = match_func.match["last_inst"][0].info.address
                ret_addr = args["call"][0].info.address + len(args["call"][0].info.opcode) + 1


                # init registers and call the targeted function
                self.sb.call_callback(
                    match_func.func_addr,
                    push_arg1,
                    push_arg2,
                    0x0,
                    cb = self.end,
                    ret_addr = ret_addr,
                    bp = func_end
                    )
                # save the deobfuscated instruction
                if self.tmp:
                    # calculate call address
                    addr = (self.tmp - push_addr3) & 0xFFFFFFFF
                    match_func.deobf_inst.append({ "args":args, "inst":"CALL {}".format(addr)})
                    self.tmp = 0

    def patch(self):
        patch = Patch(self.sb)

        print Color.step("Patching each call to {} (can take a while)".format(self.pattern.name))

        for match_func in self.pattern.matches.matches:
            for elem in match_func.deobf_inst:
                args = elem["args"]
                inst = elem["inst"]

                start = args["push3"][0].info.address
                end = args["call"][0].info.address + len(args["call"][0].info.opcode) + 1

                # patch the range with NOPs
                patch.nop_range(start, end)
                # write the deobfuscated instruction
                patch.patch(start, end, inst)

    def end(self, jitter):
        """ Callback"""
        value = struct.unpack("I", jitter.vm.get_mem(jitter.cpu.ESP, 4))[0]
        self.tmp = value

        jitter.run = False
        return False

class DetourJmp(Deobfuscation):
    """Deobfuscation function for the detour_call function.
    
    Detour class inherits of Deobfuscation.

    Attributes:
     - cfg(Dict): Config of the PushReg patterns (see. config.py)
     - pattern(Pattern): Pattern with all matches
     - tmp(int): Temporary address value (need to be fixed)
    """

    tmp_str = 0

    def __init__(self, sb):
        """Initialization"""
        Deobfuscation.__init__(self, sb)
        self.cfg = cfg.PATTERNS["detour_jmp"]
        self.pattern = Pattern(self.cfg, fpath=self.sb.fname)

        # deobfuscation
        self.deobfuscation()

        # patch
        self.patch()
    
    def deobfuscation(self):
        """ Deobfuscation of the push_reg function """
        
        print Color.step("Emulating each call to {}".format(self.pattern.name))

        # for each call to the function 
        for match_func in self.pattern.matches.matches:
            for args in match_func.args:
                push_arg1 = int(args["push1"][0].info.arg1, 16)
                push_arg2 = int(args["push2"][0].info.arg1, 16)
                push_addr2 = args["push2"][0].info.address
                func_end = match_func.match["last_inst"][0].info.address
                ret_addr = args["call"][0].info.address + len(args["call"][0].info.opcode) + 1


                # init registers and call the targeted function
                self.sb.call_callback(
                    match_func.func_addr,
                    push_arg1,
                    push_arg2,
                    cb = self.end,
                    ret_addr = ret_addr,
                    bp = func_end
                    )
                # save the deobfuscated instruction
                if self.tmp:
                    # calculate call address
                    addr = (self.tmp - push_addr2) & 0xFFFFFFFF
                    match_func.deobf_inst.append({ "args":args, "inst":"JMP {}".format(addr)})
                    self.tmp = 0

    def patch(self):
        patch = Patch(self.sb)

        print Color.step("Patching each call to {} (can take a while)".format(self.pattern.name))

        for match_func in self.pattern.matches.matches:
            for elem in match_func.deobf_inst:
                args = elem["args"]
                inst = elem["inst"]

                start = args["push2"][0].info.address
                end = args["call"][0].info.address + len(args["call"][0].info.opcode) + 1

                # patch the range with NOPs
                patch.nop_range(start, end)
                # write the deobfuscated instruction
                patch.patch(start, end, inst)

    def end(self, jitter):
        """ Callback"""
        value = struct.unpack("I", jitter.vm.get_mem(jitter.cpu.ESP, 4))[0]
        self.tmp = value

        jitter.run = False
        return False