from miasm2.analysis.sandbox import *
from miasm2.arch.x86.jit import jitter_x86_32

class Sandbox_Win_x86_32_Nymaim(Sandbox, Arch_x86_32, OS_Win):

    def __init__(self, *args, **kwargs):
        Sandbox.__init__(self, *args, **kwargs)

        # Pre-stack some arguments
        self.jitter.push_uint32_t(2)
        self.jitter.push_uint32_t(1)
        self.jitter.push_uint32_t(0)
        self.jitter.push_uint32_t(self.CALL_FINISH_ADDR)

        # Set the runtime guard
        self.jitter.add_breakpoint(self.CALL_FINISH_ADDR, self.__class__.code_sentinelle)

    def run(self, addr=None):
        """
        If addr is not set, use entrypoint
        """
        if addr is None and self.options.address is None:
            addr = self.entry_point
        super(Sandbox_Win_x86_32, self).run(addr)

    def call(self, addr, *args, **kwargs):
        """
        Direct call of the function at @addr, with arguments @args
        @addr: address of the target function
        @args: arguments
        """
        prepare_cb = kwargs.pop('prepare_cb', self.jitter.func_prepare_stdcall)
        super(self.__class__, self).call(prepare_cb, addr, *args)

    def call_callback(self, addr, *args, **kwargs):
        """
        Direct call of the function at @addr, with arguments @args
        @addr: address of the target function
        @args: arguments
        """
        prepare_cb = kwargs.pop('prepare_cb', self.jitter.func_prepare_stdcall)
        cb = kwargs.pop('cb', self.code_sentinelle)
        ret_addr =  kwargs.pop('ret_addr', self.CALL_FINISH_ADDR)
        bp =  kwargs.pop('bp', self.CALL_FINISH_ADDR)

        self.jitter.init_run(addr)
        # dirty hack
        self.jitter.remove_breakpoints_by_callback(self.code_sentinelle)
        self.jitter.add_breakpoint(bp, cb)
        prepare_cb(ret_addr, *args)
        self.jitter.continue_run()