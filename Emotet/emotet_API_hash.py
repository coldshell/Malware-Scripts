import idaapi
import sqlite3
import idautils

FUNC_API ="get_func_from_hash"
FUNC_DLL ="get_dll_from_hash"
PROTO_API = "int __cdecl {:s}(DWORD size, DWORD xor_key, PVOID out_array);".format(FUNC_API)
PROTO_DLL = "int __usercall {:s}@<eax>(DWORD dll_hash@<ecx>);".format(FUNC_DLL)

PARAMS = ["size", "key", "array"]
HASHES_DB = "emotet.db"

def get_args(call_addr):
    '''
    Get arguments of the API resolution function
    '''
    args = {}
    args_addr = idaapi.get_arg_addrs(call_addr)

    if  args_addr == None or len(args_addr) != 3:
        print("[-] Call addr: {:X}, Args: {}".format(call_addr, args_addr))
        return None

    args_value = [GetOperandValue(x, 0) for x in args_addr]
    
    for (i, arg) in enumerate(args_value):
        args[PARAMS[i]] = arg
    return args

def set_funcs():
    '''
    Set the prototypes for the functions
    '''
    SetType(LocByName(FUNC_DLL), PROTO_DLL)
    SetType(LocByName(FUNC_API), PROTO_API)

def load_hashes():
    '''
    Retrieve all sdbm hashes generated by shellcode_hash (FireEye tool)
    '''
    c = sqlite3.connect(HASHES_DB)
    db = {}
    for row  in  c.execute("select distinct source_libs.lib_name, symbol_hashes.symbol_name, symbol_hashes.hash_val from symbol_hashes, source_libs  where symbol_hashes.lib_key = source_libs.lib_key"):
        dll = row[0].encode("ascii") 
        fnc = row[1].encode("ascii") 
        hash = row[2]
        if db.has_key(dll):
            db[dll].append([fnc, hash])
        else:
            db[dll] = [[fnc, hash]] 
    return db


def xor_hash(hash, key):
    '''
    Xor the hash with the given key
    '''
    uint32 = 0xFFFFFFFF
    return (hash ^ key) & uint32


def search_hashes(db, args):
    '''
    Resolution of the API

    Arguments:
      - db (dict): database generated by shellcode_hash
      - args (dict): call arguments 
    '''
    # Get information about the .text section
    text_segm = ida_segment.get_segm_by_name('.text')
    seg_start = text_segm.startEA
    seg_end = text_segm.endEA

    # Iter over the sdbm hashes generated by shellcode_hash
    for (dll, funcs) in db.items():
        print("Searching for functions inside the {} DLL".format(dll))

        for func, hash in funcs:
            new_hash = xor_hash(hash, args["key"])

            #search for hashes
            ea = idaapi.find_binary(seg_start, seg_end, "0x{:08X}".format(new_hash), 16, SEARCH_DOWN)
            if ea != BADADDR:
                # Add comment
                inst_ea = PrevHead(ea) 
                print("Match the hash: {:X} which is the function {}!{} matches: 0x{:X}".format(new_hash, dll, func, inst_ea))
                MakeComm(inst_ea, "{}!{}".format(dll, func))

                # Fix variable name in the function array
                off = (GetOperandValue(inst_ea, 0) ^ 0xffffffff) + 1
                array_off = (args['size'] * 4) - off
                array_va = args['array'] + array_off
                MakeDword(array_va)

                if not MakeName(array_va, "{}".format(func)):
                    MakeName(array_va, "{}_{}".format(dll, func))
                print("Fix the name at 0x{:08X}".format(array_va))

def search_dll_hashes(db):
    '''
    Search for DLL hashes
    '''
    # Get information about the .text section
    text_segm = ida_segment.get_segm_by_name('.text')
    seg_start = text_segm.startEA
    seg_end = text_segm.endEA

    # Iter over dll names
    for (dll, funcs) in db.items():
        print("Searching for the {} DLL".format(dll))
        new_hash = sdbm_hash(dll)

        #search for hashes
        ea = idaapi.find_binary(seg_start, seg_end, "0x{:08X}".format(new_hash), 16, SEARCH_DOWN)
        if ea != BADADDR:
            inst_ea = PrevHead(ea) 
            print("Match the hash: {:X} which is the DLL {}, match: 0x{:X}".format(new_hash, dll, inst_ea))
            MakeComm(inst_ea, "{}".format(dll))

def sdbm_hash(inString):
    '''
    Implementation of the sdbm
    '''
    if inString is None:
        return 0
    hash = 0 
    uint32 = 0xFFFFFFFF
    for char in inString:
        hash = (ord(char) + 0x1003F * hash) & uint32
    return hash

def reanalyze_code():
    '''
    Reanalyze .text section
    '''
    text_segm = ida_segment.get_segm_by_name('.text')
    seg_start = text_segm.startEA
    seg_end = text_segm.endEA
    AnalyzeArea(seg_start, seg_end)

# Set functions type
set_funcs()
# Reanalyze the code 
reanalyze_code()

# Resolution of imported functions
db = load_hashes()
for xref in XrefsTo(LocByName(FUNC_API)):
    args = get_args(xref.frm)
    print("[+] API resolution for the XREF 0x{:08X}".format(xref.frm))
    search_hashes(db, args)

# Resolution of DLL name
search_dll_hashes(db)
